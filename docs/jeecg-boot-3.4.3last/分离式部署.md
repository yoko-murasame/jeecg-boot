[返回](../)

# 分离式部署

针对单体应用的分离式打包+Docker部署。


**直接部署方式**

Jar包运行脚本:
* [start.sh](https://github.com/yoko-murasame/jeecg-boot/blob/yoko-3.4.3last/docs/DevOps/app/backend/start.sh)

启动命令:
```shell
# 先修改脚本配置, 详情见脚本内容
#启动
sh start.sh start
#停止
sh start.sh stop
#重启
sh start.sh restart
#查看状态
sh start.sh status
```

**Docker部署方式**

Dockerfile:
* [Dockerfile_Separate](https://github.com/yoko-murasame/jeecg-boot/blob/yoko-3.4.3last/jeecg-module-system/jeecg-system-start/Dockerfile_Separate)
* [Dockerfile_SuperMap](https://github.com/yoko-murasame/jeecg-boot/blob/yoko-3.4.3last/jeecg-module-system/jeecg-system-start/Dockerfile_SuperMap)

Docker方式部署:
```shell
# 防火墙
firewall-cmd --zone=public --add-port=8888/tcp --permanent && firewall-cmd --reload

## 单体应用分离式打包
# 构建容器
docker build -t app-image -f Dockerfile_Separate .
docker save -o ./app-image app-image
# 第一次载入镜像
docker load -i app-image
# 启动
docker run -di --name app-container --restart=unless-stopped -p 9999:8888 -v /application/app:/app -v /application/upFiles:/opt/upFiles app-image

## 超图依赖的应用打包
https://blog.csdn.net/SerikaOnoe/article/details/130337989
```

Redis部署:
```shell
# 拉取
docker pull redis
# 下载镜像
docker save -o /mnt/d/redis-image redis:latest
# 推送镜像到服务器
# 加载镜像
docker load -i redis-image
# 查看已有镜像
docker images
# 启动，端口63791，密码123456 配置映射 -v /home/redis/redis.conf:/etc/redis/redis.conf
docker run -di --restart=unless-stopped --name=redis \
-p 63791:63791 \
-v /home/redis/data:/data \
redis:latest --requirepass "123456" --port "63791" --appendonly "yes";
# 进入容器
docker exec -it redis /bin/bash
# 测试启动
redis-cli -h 127.0.0.1 -p 63791
auth 123456
set name test
get name
# 通过别的服务器连接测试
curl 127.0.0.1:63791
# curl: (52) Empty reply from server 即连接是通的
```

### 容器启动脚本

**多容器启动脚本**
```shell
#!/bin/bash

# 配置容器和镜像名称
container_names=("redis-test" "mysql-test")
image_names=("redis" "mysql")

# 创建容器命令数组
create_container_cmds=("docker run -d --name ${container_names[0]} ${image_names[0]}"
                      "docker run -d --name ${container_names[1]} ${image_names[1]}")

# 启动容器函数
start_container() {
    local container_name="$1"
    echo "启动 $container_name 容器..."
    docker start "$container_name"
    echo "$container_name 容器已启动。"
}

# 停止容器函数
stop_container() {
    local container_name="$1"
    echo "停止 $container_name 容器..."
    docker stop "$container_name"
    echo "$container_name 容器已停止。"
}

# 重启容器函数
restart_container() {
    local container_name="$1"
    echo "重启 $container_name 容器..."
    docker restart "$container_name"
    echo "$container_name 容器已重启。"
}

# 检查容器状态
container_status() {
    local container_name="$1"
    docker inspect -f '{{.State.Status}}' "$container_name" 2>/dev/null
}

# 根据用户输入的参数调用相应的功能
if [ "$1" == "start" ]; then
    # 启动容器
    for ((i=0; i<${#container_names[@]}; i++)); do
        container_name="${container_names[i]}"
        image_name="${image_names[i]}"
        create_container_cmd="${create_container_cmds[i]}"
        
        if [ -z "$(container_status "$container_name")" ]; then
            echo "创建 $container_name 容器..."
            eval "$create_container_cmd"
            echo "$container_name 容器已创建并启动。"
        elif [ "$(container_status "$container_name")" == "exited" ]; then
            start_container "$container_name"
        elif [ "$(container_status "$container_name")" == "running" ]; then
            echo "$container_name 容器已经在运行中。"
        fi
    done
elif [ "$1" == "stop" ]; then
    # 停止容器
    for container_name in "${container_names[@]}"; do
        if [ -n "$(container_status "$container_name")" ] && [ "$(container_status "$container_name")" == "running" ]; then
            stop_container "$container_name"
        else
            echo "$container_name 容器未运行。"
        fi
    done
elif [ "$1" == "restart" ]; then
    # 重启容器
    for container_name in "${container_names[@]}"; do
        if [ -n "$(container_status "$container_name")" ] && [ "$(container_status "$container_name")" == "running" ]; then
            restart_container "$container_name"
        else
            echo "$container_name 容器未运行，无法重启。"
        fi
    done
else
    echo "无效的参数。请使用 'start'、'stop' 或 'restart'。"
fi

```

**单容器启动脚本**
```shell
#!/bin/bash

# 配置容器和镜像名称
container_name="redis-test"
image_name="redis"

# 创建容器命令
create_container_cmd="docker run -d --name $container_name $image_name"

# 启动容器函数
start_container() {
    echo "启动 $container_name 容器..."
    docker start "$container_name"
    echo "$container_name 容器已启动。"
}

# 停止容器函数
stop_container() {
    echo "停止 $container_name 容器..."
    docker stop "$container_name"
    echo "$container_name 容器已停止。"
}

# 重启容器函数
restart_container() {
    echo "重启 $container_name 容器..."
    docker restart "$container_name"
    echo "$container_name 容器已重启。"
}

# 检查容器状态
container_status=$(docker inspect -f '{{.State.Status}}' "$container_name" 2>/dev/null)

# 根据用户输入的参数调用相应的功能
if [ "$1" == "start" ]; then
    # 启动容器
    if [ -z "$container_status" ]; then
        echo "创建 $container_name 容器..."
        eval "$create_container_cmd"
        echo "$container_name 容器已创建并启动。"
    elif [ "$container_status" == "exited" ]; then
        start_container
    elif [ "$container_status" == "running" ]; then
        echo "$container_name 容器已经在运行中。"
    fi
elif [ "$1" == "stop" ]; then
    # 停止容器
    if [ -n "$container_status" ] && [ "$container_status" == "running" ]; then
        stop_container
    else
        echo "$container_name 容器未运行。"
    fi
elif [ "$1" == "restart" ]; then
    # 重启容器
    if [ -n "$container_status" ] && [ "$container_status" == "running" ]; then
        restart_container
    else
        echo "$container_name 容器未运行，无法重启。"
    fi
else
    echo "无效的参数。请使用 'start'、'stop' 或 'restart'。"
fi

```


修改历史:
* 2023-07-13: 新增。
* 2023-07-18: 新增Docker部署方式、传统脚本部署方式、Redis配置
