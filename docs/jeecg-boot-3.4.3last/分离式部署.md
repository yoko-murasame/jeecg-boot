[返回](../)

# 分离式部署

针对单体应用的分离式打包+Docker部署。


**直接部署方式**

Jar包运行脚本:
* [start.sh](https://github.com/yoko-murasame/jeecg-boot/blob/yoko-3.4.3last/docs/DevOps/app/start.sh)

启动命令:
```shell
# 先修改脚本配置, 详情见脚本内容
#启动
sh start.sh start
#停止
sh start.sh stop
#重启
sh start.sh restart
#查看状态
sh start.sh status
```

**Docker部署方式**

Dockerfile:
* [Dockerfile_Separate](https://github.com/yoko-murasame/jeecg-boot/blob/yoko-3.4.3last/jeecg-module-system/jeecg-system-start/Dockerfile_Separate)
* [Dockerfile_SuperMap](https://github.com/yoko-murasame/jeecg-boot/blob/yoko-3.4.3last/jeecg-module-system/jeecg-system-start/Dockerfile_SuperMap)

Docker方式部署:
```shell
# 防火墙
firewall-cmd --zone=public --add-port=8888/tcp --permanent && firewall-cmd --reload

## 单体应用分离式打包
# 构建容器
docker build -t app-image -f Dockerfile_Separate .
docker save -o ./app-image app-image
# 第一次载入镜像
docker load -i app-image
# 启动
docker run -di --name app-container --restart=unless-stopped -p 9999:8888 -v /application/app:/app -v /application/upFiles:/opt/upFiles app-image

## 超图依赖的应用打包
https://blog.csdn.net/SerikaOnoe/article/details/130337989
```

Redis部署:
```shell
# 拉取
docker pull redis
# 下载镜像
docker save -o /mnt/d/redis-image redis:latest
# 推送镜像到服务器
# 加载镜像
docker load -i redis-image
# 查看已有镜像
docker images
# 启动，端口63791，密码123456
docker run -di --restart=unless-stopped --name=redis -p 63791:63791 redis:latest --requirepass "123456" --port "63791" --appendonly "yes"
# 进入容器
docker exec -it redis /bin/bash
# 测试启动
redis-cli -p 63791
auth 123456
set name test
get name
# 通过别的服务器连接测试
curl 127.0.0.1:63791
# curl: (52) Empty reply from server 即连接是通的
```

修改历史:
* 2023-07-13: 新增。
* 2023-07-18: 新增Docker部署方式、传统脚本部署方式、Redis配置
